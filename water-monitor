#!/usr/bin/python3

import RPi.GPIO as GPIO
import time
import os
from contextlib import ExitStack
from PulseCounter import PulseCounter
from MQTTClient import MQTTClient
from PressureSensor import PressureSensor

import configparser


GPIO.setmode(GPIO.BCM)

# GPIO INPUT PINS
# GPIO 2 and 3 (pins 3 and 5) are used for I2C
# 
FIRE_FLOW = 17             # Pin 11
HOUSE_FLOW_PULSE = 27      # Pin 13
IRRIGATION_FLOW_PULSE = 22 # Pin 15

GPIO.setup(FIRE_FLOW, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(HOUSE_FLOW_PULSE, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(IRRIGATION_FLOW_PULSE, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)

# Setup MQTT connection



class PressureSensorData:
    def __init__(self, topic, minSafe, maxSafe):
        self.topic = topic
        self.minSafe = minSafe
        self.maxSafe = maxSafe

        self.pressure = 0
        self.minPressure = 0
        self.maxPressure = 0
    
    def Input(self,input):
        self.pressure = input
        self.maxPressure = max(self.pressure, self.maxPressure)
        self.minPressure = min(self.pressure, self.minPressure)
        # print(self.topic + ": " + str(self.pressure))

class FlowSensorData:
    def __init__(self, topic):
        self.topic = topic
        self.totalVolume = 0
        self.dailyVolume = 0
        self.dailyAverage = 0
        self.numDays = 0
        self.currentFlowRate = 0
        self.pulseCounter = PulseCounter()

    def EnterContext(self, stack):
        self.pulseCounter.EnterContext(stack)

    def GetCurrentGPM(self):
        return self.pulseCounter.GetCurrentGPM()
    def GetDailyVolume(self):
        return self.pulseCounter.GetTotalVolume()
    def GetDailyAverage(self):
        return self.dailyAverage
    def GetMaxGPM(self):
        return 0 # TODO input loop should track this

    def Input(self, input):
        self.pulseCounter.Input(input)
        # Check if this is a new day, and update dailys


class DataPublisher():
    # handle the stats data itself regarding all water and plumbing systems
    # decide when and what to publish to MQTT.
    #
    # Generally speaking, data is only published to MQTT when changes occur. All
    # data is published with retain=1 to allow instant display of current stats
    # on dashboard startup (or any client connection)
    #
    # This class is intended to sit in between the "input thread" and the
    # "publishing thread" This separates into two contexts the inputs vs the
    # decisions of what and when to publish.  This is important as the input
    # thread is very timing sensitive so as to not miss any signal transitions,
    # and since the publishing thread is dealing with MQTT communications (which
    # may block), these responsibilities must be handled in separate threads.
    def __init__(self):
        self.fireFlow = False
        self.houseFlow = FlowSensorData("water/houseFlow")
        self.irrigationFlow = FlowSensorData("water/irrigationFlow")
        self.inletPressure = PressureSensorData("water/inlet", 5, 40)
        self.outletPressure = PressureSensorData("water/outlet", 60, 90)
        self.mqttInletMinPressure = 0
        self.mqttInletMaxPressure = 0
        self.mqttOutletMinPressure = 0
        self.mqttOutletMaxPressure = 0

    def EnterContext(self, stack):
        self.houseFlow.EnterContext(stack)
        self.irrigationFlow.EnterContext(stack)

    def fireFlowInput(self, isFlowing):
        if (isFlowing and self.fireFlow == False):
            self.fireFlow = True # latches ON until explicitly cleared via MQTT
    def GetFireFlow(self):
        if (self.fireFlow == True):
            self.fireFlow = False
            return True
        else:
            return False

    def houseFlowInput(self, input):
        self.houseFlow.pulseCounter.Input(input)

    def irrigationFlowInput(self, input):
        self.irrigationFlow.pulseCounter.Input(input)

    def inletPressureInput(self, input):
        self.inletPressure.Input(input)

    def outletPressureInput(self, input):
        self.outletPressure.Input(input)

    def receivedMessage(self, topic, payload):
        if topic == "water/inlet/minPressure":
            self.mqttInletMinPressure = float(payload)
            print("Reset inlet min to " + str(payload))
        if topic == "water/inlet/maxPressure":
            self.mqttInletMaxPressure = float(payload)
            print("Reset inlet max to " + str(payload))
        if topic == "water/outlet/minPressure":
            self.mqttOutletMinPressure = float(payload)
            print("Reset outlet min to " + str(payload))
        if topic == "water/outlet/maxPressure":
            self.mqttOutletMinPressure = float(payload)
            print("Reset outlet max to " + str(payload))
        if topic == "water/alarm":
            print("Set Alarm state: " + str(payload))

    def getMessagesToPublish(self):
        # TODO only publish what has changed
        # Returns an array of messages which can be published via paho MQTT's
        # "publish multiple"
        #
        # Create a list of all current pairs
        pairs = []
        if self.GetFireFlow():
            pairs.append({'topic':"water/fireFlow",'payload':str(True)})
        pairs.append({'topic':"water/houseFlow/currentGPM",'payload':str(self.houseFlow.GetCurrentGPM())})
        pairs.append({'topic':"water/houseFlow/maxGPM",'payload':str(self.houseFlow.GetMaxGPM())})
        pairs.append({'topic':"water/houseFlow/dailyVolume",'payload':str(self.houseFlow.GetDailyVolume())})
        pairs.append({'topic':"water/houseFlow/dailyAverage",'payload':str(self.houseFlow.GetDailyAverage())})
        pairs.append({'topic':"water/irrigationFlow/currentGPM",'payload':str(self.irrigationFlow.GetCurrentGPM())})
        pairs.append({'topic':"water/irrigationFlow/maxGPM",'payload':str(self.irrigationFlow.GetMaxGPM())})
        pairs.append({'topic':"water/irrigationFlow/dailyVolume",'payload':str(self.irrigationFlow.GetDailyVolume())})
        pairs.append({'topic':"water/irrigationFlow/dailyAverage",'payload':str(self.irrigationFlow.GetDailyAverage())})
        pairs.append({'topic':"water/inlet/pressure",'payload':str(self.inletPressure.pressure)})
        pairs.append({'topic':"water/outlet/pressure",'payload':str(self.outletPressure.pressure)})
        if (self.inletPressure.minPressure < self.mqttInletMinPressure):
            pairs.append({'topic':"water/inlet/minPressure",'payload':str(self.inletPressure.minPressure)})
        if (self.inletPressure.maxPressure > self.mqttInletMaxPressure):            
            pairs.append({'topic':"water/inlet/maxPressure",'payload':str(self.inletPressure.maxPressure)})
        if (self.outletPressure.minPressure < self.mqttOutletMinPressure):
            pairs.append({'topic':"water/outlet/minPressure",'payload':str(self.outletPressure.minPressure)})
        if (self.outletPressure.maxPressure > self.mqttOutletMaxPressure):
            pairs.append({'topic':"water/outlet/maxPressure",'payload':str(self.outletPressure.maxPressure)})

        msgs = []
        for x in pairs:
            x['qos'] = 1
            x['retain'] = True
            msgs.append(x)
        
        return msgs
    
        

        
try:
    config = configparser.ConfigParser()
    config.read('water-monitor.ini')
    p = DataPublisher()
    mqtt = MQTTClient(p,config['MQTT']['Host'],
                        int(config['MQTT']['Port']),
                        config['MQTT']['Username'],
                        config['MQTT']['Password'])
    pressureSensor = PressureSensor()
    with ExitStack() as stack:
        p.EnterContext(stack)
        stack.enter_context(mqtt)
        stack.enter_context(pressureSensor)
        while True:
            # Report values of all GPIO inputs to the DataHandler
            p.fireFlowInput(GPIO.input(FIRE_FLOW))

            p.houseFlowInput(GPIO.input(HOUSE_FLOW_PULSE))
            p.irrigationFlowInput(GPIO.input(IRRIGATION_FLOW_PULSE))

            # Read Inlet/Outlet Pressures over I2C
            p.inletPressureInput(pressureSensor.inletPressure)
            p.outletPressureInput(pressureSensor.outletPressure)

            time.sleep(0.1)

except KeyboardInterrupt:
    GPIO.cleanup()
